static GAME_OVER: bool;
static RNG: u64;
static SCORE_BUF: [u8; 10];
static PLAYERS: [Player; 4];
static CURRENT_PLAYER: usize;
static CURRENT_GAME_PHASE: GamePhase;
static BIDS: [Bid; 25];
static BIDS_SIZE: usize; // less than 0
static BID_STRING_BUF: [u8; 100];

enum Suit {
  Clubs,
  Diamonds,
  Hearts,
  Spades,
}

enum BidSuit {
  Clubs,
  Diamonds,
  Hearts,
  Spades,
  NoTrump
}

enum Value {
  Ace,
  Two,
  Three,
  Four,
  Five,
  Six,
  Seven,
  Eight,
  Nine,
  Ten,
  Jack,
  King,
  Queen,
}

struct Card {
  suit: Suit,
  value: Value,
}

struct PlayerHand {
  hand: [Card; 13],
  hand_size: usize,
}

enum Seat {
  North,
  East,
  South,
  West,
}

struct Player {
  id: u32,
  hand: PlayerHand,
  seat: Seat,
}

enum GamePhase {
  Bidding,
  Playing,
  GameOver,
}

struct Bid {
  value: u32, // 1 - 7
  suit: BidSuit,
}

proc rand() -> u64 {
   RNG = RNG ^ (RNG << 13);
   RNG = RNG ^ (RNG >> 7);
   RNG = RNG ^ (RNG << 17);
   return RNG;
}

proc rand_range(rand_min: u64, rand_max: u64) -> u64 {
   return rand() % (rand_max + 1 - rand_min) + rand_min;
}

proc one_in(x: u64) -> bool {
   return rand_range(0, x - 1) == 0;
}

proc reset_game() {
   GAME_OVER = false;
   RNG = 2;
   CURRENT_PLAYER = 0;
   CURRENT_GAME_PHASE = GamePhase::Bidding;
   // Deal out cards. For now, deal everyone the ace of spades.
   deal_cards();
}

proc deal_cards() {
 for i in 0..PLAYERS.length {
     PLAYERS[i] = Player {
       id: i transmute u32,
       hand: PlayerHand {
         hand: [Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Ace,
         },Card {
           suit: Suit::Spades,
           value: Value::Queen,
         }],
       hand_size: 13,
       },
       seat: Seat::North,
     };
   }
}

proc card_value_to_u8(value: Value) -> u8 {
  if value == Value::Ace {
    return "A".pointer~;
  }
  if value == Value::Two {
    return "2".pointer~;
  }
  if value == Value::Three {
    return "3".pointer~;
  }
  if value == Value::Four {
    return "4".pointer~;
  }
  if value == Value::Five {
    return "5".pointer~;
  }
  if value == Value::Six {
    return "6".pointer~;
  }
  if value == Value::Seven {
    return "7".pointer~;
  }
  if value == Value::Eight {
    return "8".pointer~;
  }
  if value == Value::Nine {
    return "9".pointer~;
  }
  if value == Value::Ten {
    return "10".pointer~;
  }
  if value == Value::Jack {
    return "J".pointer~;
  }
  if value == Value::Queen {
    return "Q".pointer~;
  }
  if value == Value::King {
    return "K".pointer~;
  }
  return "X".pointer~;
}

proc draw_player_hand(player_index: usize) {
  let hand: PlayerHand = PLAYERS[player_index].hand;
  trace("drawing player hand");
  let bid_ui_string = String {
    length: 0,
    pointer: &BID_STRING_BUF[0],
  };

  for i in 0..hand.hand_size {
    BID_STRING_BUF[i] = card_value_to_u8(hand.hand[i].value);
    bid_ui_string.length = bid_ui_string.length +1;
  }
  trace(bid_ui_string);
  text(bid_ui_string, 2, 2);
}

proc start() {
   PALETTE~ = [16774867, 16361589, 15428463, 8142680];
   SYSTEM_FLAGS~ = SYSTEM_HIDE_GAMEPAD_OVERLAY;
   reset_game();
}

proc update() {
   if CURRENT_GAME_PHASE == GamePhase::GameOver {
     trace("game is over");
   }
   else if CURRENT_GAME_PHASE == GamePhase::Bidding {
     trace("bidding");
     // for the player whose turn it is, if they made an input on the last frame:
     //   update the bid
     //
     // draw bid UI
     draw_player_hand(CURRENT_PLAYER);
   }
   else if CURRENT_GAME_PHASE == GamePhase::Playing {
     trace("playing");
   }

   // Handle input
   let button_pressed = (GAMEPADS~[0] & BUTTON_1) > 0;
   let mouse_pressed = (MOUSE_BUTTONS~ & MOUSE_LEFT) > 0;
   // Draw world
   {

   }
}
